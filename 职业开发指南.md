# 职业开发指南

## 一、文件结构

```
src/main/java/org/alku/life_contract/
├── profession/
│   ├── Profession.java          # 职业数据类
│   ├── ProfessionBuilder.java   # 职业构建器
│   └── ProfessionConfig.java    # 职业配置管理
├── ContractEvents.java          # 核心事件处理
└── [职业名]System.java          # 职业专用系统（可选）
```

## 二、添加新职业步骤

### 步骤1：在 Profession.java 中添加属性

```java
// 1. 添加私有字段
private final boolean isYourProfession;
private final int yourProfessionValue;

// 2. 在构造函数中初始化
Profession(ProfessionBuilder builder) {
    // ... 其他属性
    this.isYourProfession = builder.isYourProfession();
    this.yourProfessionValue = builder.getYourProfessionValue();
}

// 3. 添加 getter 方法
public boolean isYourProfession() { return isYourProfession; }
public int getYourProfessionValue() { return yourProfessionValue; }

// 4. 在 save() 方法中保存到 NBT
public CompoundTag save() {
    // ... 其他属性
    tag.putBoolean("isYourProfession", isYourProfession);
    tag.putInt("yourProfessionValue", yourProfessionValue);
    return tag;
}

// 5. 在 writeToBuffer() 方法中写入网络数据
public void writeToBuffer(FriendlyByteBuf buffer) {
    // ... 其他属性
    buffer.writeBoolean(isYourProfession);
    buffer.writeInt(yourProfessionValue);
}
```

### 步骤2：在 ProfessionBuilder.java 中添加构建方法

```java
// 1. 添加私有字段（带默认值）
private boolean isYourProfession = false;
private int yourProfessionValue = 100;

// 2. 添加 setter 方法（链式调用）
public ProfessionBuilder isYourProfession(boolean isYourProfession) { 
    this.isYourProfession = isYourProfession; 
    return this; 
}
public ProfessionBuilder yourProfessionValue(int yourProfessionValue) { 
    this.yourProfessionValue = yourProfessionValue; 
    return this; 
}

// 3. 在 fromNBT() 方法中加载
public static ProfessionBuilder fromNBT(CompoundTag tag) {
    // ... 其他属性
    builder.isYourProfession(tag.contains("isYourProfession") && tag.getBoolean("isYourProfession"));
    builder.yourProfessionValue(tag.contains("yourProfessionValue") ? tag.getInt("yourProfessionValue") : 100);
    return builder;
}

// 4. 在 fromBuffer() 方法中加载
public static ProfessionBuilder fromBuffer(FriendlyByteBuf buffer) {
    // ... 其他属性
    builder.isYourProfession(buffer.readBoolean());
    builder.yourProfessionValue(buffer.readInt());
    return builder;
}

// 5. 添加 getter 方法
boolean isYourProfession() { return isYourProfession; }
int getYourProfessionValue() { return yourProfessionValue; }
```

### 步骤3：在 ProfessionConfig.java 中添加 JSON 加载

```java
// 在 loadProfessionFromJson() 方法中添加
private static Profession loadProfessionFromJson(JsonObject json) {
    ProfessionBuilder builder = Profession.builder()
        // ... 其他属性
        .isYourProfession(json.has("isYourProfession") && json.get("isYourProfession").getAsBoolean())
        .yourProfessionValue(json.has("yourProfessionValue") ? json.get("yourProfessionValue").getAsInt() : 100);
    
    return builder.build();
}
```

### 步骤4：在 ContractEvents.java 中实现技能逻辑

```java
// 方式1：在现有事件中添加
@SubscribeEvent
public static void onLivingDamage(LivingDamageEvent event) {
    if (!(event.getSource().getEntity() instanceof ServerPlayer player)) return;
    
    String professionId = getEffectiveProfessionId(player);
    if (professionId == null || professionId.isEmpty()) return;
    
    Profession profession = ProfessionConfig.getProfession(professionId);
    if (profession == null) return;
    
    // 添加你的职业逻辑
    if (profession.isYourProfession()) {
        // 技能实现
    }
}

// 方式2：创建独立的事件处理器（推荐用于复杂职业）
@SubscribeEvent
public static void onYourProfessionAttack(LivingAttackEvent event) {
    if (event.getEntity().level().isClientSide()) return;
    if (!(event.getSource().getEntity() instanceof ServerPlayer player)) return;
    
    String professionId = getEffectiveProfessionId(player);
    if (professionId == null || professionId.isEmpty()) return;
    
    Profession profession = ProfessionConfig.getProfession(professionId);
    if (profession == null || !profession.isYourProfession()) return;
    
    // 技能实现
    LivingEntity target = event.getEntity();
    // ... 你的技能逻辑
}
```

### 步骤5：在配置文件中添加职业

文件位置：`run/config/life_contract_professions.json`

```json
{
  "professions": [
    {
      "id": "your_profession",
      "name": "你的职业名",
      "description": "职业描述",
      "requiresPassword": false,
      "password": "",
      "iconItem": "minecraft:diamond",
      
      "isYourProfession": true,
      "yourProfessionValue": 100,
      
      "bonusDamagePercent": 0.0,
      "slownessLevel": 0,
      "weaknessLevel": 0,
      "bonusArmor": 0.0,
      "bonusHealth": 0.0,
      "meleeDamageBonus": 0.0,
      
      "isHealer": false,
      "isDeathVenger": false,
      "isGhostSenator": false
    }
  ]
}
```

## 三、常用事件类型

| 事件 | 触发时机 | 用途 |
|------|----------|------|
| `LivingAttackEvent` | 攻击发生时 | 攻击触发技能 |
| `LivingDamageEvent` | 伤害计算时 | 修改伤害值 |
| `LivingHurtEvent` | 受伤时 | 受伤触发效果 |
| `LivingDeathEvent` | 死亡时 | 死亡触发效果 |
| `TickEvent.ServerTickEvent` | 每tick | 周期性效果 |
| `PlayerEvent.PlayerLoggedInEvent` | 玩家加入 | 初始化 |

## 四、常用效果 API

```java
// 添加药水效果
player.addEffect(new MobEffectInstance(
    MobEffects.DAMAGE_BOOST,  // 效果类型
    200,                       // 持续时间（ticks）
    0,                         // 等级（0=I, 1=II）
    false,                     // 是否显示粒子
    true                       // 是否显示图标
));

// 常用药水效果
MobEffects.DAMAGE_BOOST       // 力量
MobEffects.MOVEMENT_SPEED     // 速度
MobEffects.REGENERATION       // 生命恢复
MobEffects.RESISTANCE         // 抗性
MobEffects.FIRE_RESISTANCE    // 防火
MobEffects.INVISIBILITY       // 隐身
MobEffects.POISON             // 中毒
MobEffects.WEAKNESS           // 虚弱
MobEffects.MOVEMENT_SLOWDOWN  // 缓慢
MobEffects.WITHER             // 凋零
MobEffects.BLINDNESS          // 失明

// 治疗
player.heal(10.0f);

// 发送消息
player.sendSystemMessage(Component.literal("§a[职业] §f技能触发！"));

// 粒子效果
if (player.level() instanceof ServerLevel serverLevel) {
    serverLevel.sendParticles(
        ParticleTypes.EXPLOSION,
        player.getX(), player.getY(), player.getZ(),
        10,  // 数量
        0.5, 0.5, 0.5,  // 偏移
        0.1  // 速度
    );
}

// 播放声音
player.level().playSound(null, player.getX(), player.getY(), player.getZ(),
    SoundEvents.PLAYER_ATTACK_CRIT, SoundSource.PLAYERS, 1.0f, 1.0f);
```

## 五、完整示例：邪毒者职业

### Profession.java 添加
```java
private final boolean isEvilPoisoner;
private final int poisonerStrengthDuration;

// 构造函数中
this.isEvilPoisoner = builder.isEvilPoisoner();
this.poisonerStrengthDuration = builder.getPoisonerStrengthDuration();

// getter
public boolean isEvilPoisoner() { return isEvilPoisoner; }
public int getPoisonerStrengthDuration() { return poisonerStrengthDuration; }
```

### ContractEvents.java 实现
```java
@SubscribeEvent
public static void onEvilPoisonerAttack(LivingAttackEvent event) {
    if (event.getEntity().level().isClientSide()) return;
    if (!(event.getSource().getEntity() instanceof ServerPlayer player)) return;
    
    String professionId = getEffectiveProfessionId(player);
    if (professionId == null || professionId.isEmpty()) return;
    
    Profession profession = ProfessionConfig.getProfession(professionId);
    if (profession == null || !profession.isEvilPoisoner()) return;
    
    LivingEntity target = event.getEntity();
    int duration = profession.getPoisonerStrengthDuration();
    
    // 攻击者获得力量
    player.addEffect(new MobEffectInstance(MobEffects.DAMAGE_BOOST, duration, 0, false, true));
    
    // 受击者获得随机debuff
    MobEffect[] debuffs = {
        MobEffects.POISON, MobEffects.WEAKNESS, MobEffects.MOVEMENT_SLOWDOWN,
        MobEffects.WITHER, MobEffects.HUNGER, MobEffects.BLINDNESS
    };
    MobEffect randomDebuff = debuffs[new Random().nextInt(debuffs.length)];
    target.addEffect(new MobEffectInstance(randomDebuff, 200, 2, false, true));
}
```

### JSON 配置
```json
{
  "id": "poisoner",
  "name": "邪毒者",
  "description": "攻击时获得力量，敌人获得随机debuff",
  "isEvilPoisoner": true,
  "poisonerStrengthDuration": 200
}
```

## 六、注意事项

1. **属性命名规范**：使用 `is` 前缀表示布尔值，如 `isHealer`、`isEvilPoisoner`
2. **默认值**：在 Builder 中设置合理的默认值
3. **空值检查**：在事件处理中始终检查 `profession != null`
4. **客户端检查**：事件开始时检查 `!level.isClientSide()`
5. **配置同步**：修改代码后需要重新构建并重启服务器
